<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Storium Interactive</title>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; }
        .tabs { display: flex; border-bottom: 2px solid #ccc; }
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: #f7f7f7;
            font-weight: bold;
            outline: none;
        }
        .tab.active { background: #fff; border-bottom: 2px solid #fff; }
        .tab-content { display: none; padding: 24px; }
        .tab-content.active { display: block; }
        .dropdown-editable {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        .dropdown-editable select, .dropdown-editable input[type="text"] {
            font-size: 1em;
            padding: 4px;
        }
        .crud-btn {
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 6px;
            margin-left: 2px;
            cursor: pointer;
            font-size: 1em;
        }
        .treeview { margin-left: 16px; }
        .tree-group {
            margin-bottom: 8px;
            border-left: 2px solid #ddd;
            padding-left: 8px;
        }
        .tree-item {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }
        .tree-label { font-weight: 500; }
        .scene, .character, .desc { margin-left: 16px; }
        .character-cards {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            max-width: 320px;
            margin-left: 32px;
            margin-bottom: 8px;
        }
        .character-card {
            min-width: 90px;
            border: 1px solid #bbb;
            border-radius: 4px;
            padding: 6px;
            background: #fafafa;
            text-align: center;
        }
        .textarea-large {
            width: 100%;
            min-height: 180px;
            font-size: 1em;
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
        }
        .icon-btn {
            background: #e0e0e0;
            border: 1px solid #bbb;
            border-radius: 3px;
            padding: 4px 10px;
            margin-right: 6px;
            cursor: pointer;
            font-size: 1em;
            vertical-align: middle;
        }
        .todo-area {
            width: 100%;
            min-height: 120px;
            margin-bottom: 8px;
            border: 1px dashed #bbb;
            background: #f9f9f9;
            color: #aaa;
            padding: 8px;
            border-radius: 4px;
            resize: vertical;
        }
    </style>
</head>
<body>
    <div class="tabs">
        <button class="tab active" data-tab="0">Storium</button>
        <button class="tab" data-tab="1">Table Builder</button>
    </div>
    <div class="tab-content active" id="tab1">
        <!-- Editable Dropdown with CRUD -->
        <div class="dropdown-editable">
            <label for="gamesDropdown"><b>Games</b></label>
            <select id="gamesDropdown"></select>
            <button class="crud-btn" title="Create Game" onclick="createGame()">ï¼‹</button>
            <button class="crud-btn" title="Remove Game" onclick="removeGame()">ðŸ—‘</button>
            <button class="crud-btn" title="Update Game" onclick="updateGame()">âœŽ</button>
        </div>
        <!-- TreeView for chosen game -->
        <div id="treeView"></div>
    </div>
    <div class="tab-content" id="tab2">
        <textarea class="textarea-large" id="tableTextArea" placeholder="Edit or paste table definitions here..."></textarea>
        <div>
            <button class="icon-btn" onclick="buildTables()">ðŸ”¨ Build</button>
            <button class="icon-btn" onclick="loadFromTree()">âŸ³ Load from Tree</button>
        </div>
        <textarea class="todo-area" readonly placeholder="TODO: Area 2 (unimplemented)"></textarea>
        <textarea class="todo-area" readonly placeholder="TODO: Area 3 (unimplemented)"></textarea>
    </div>
    <script>

        // Load CssManagement library
        let CssManagementLoaded = false;
        function loadCssManagement(cb) {
            if (CssManagementLoaded) { cb(); return; }
            const script = document.createElement('script');
            script.src = 'https://raw.githubusercontent.com/Cava1ier/libraries/refs/heads/main/css/css-management.js';
            script.onload = function() { CssManagementLoaded = true; cb(); };
            document.head.appendChild(script);
        }

        // --- StoriumData: Data IIFE ---
        window.StoriumData = (function() {
            let state = {
                games: [], players: [], gameSettings: [], characters: [], playersCharacters: [], cardTypes: [], cards: [], charactersCards: [], scenes: [], sceneCharacters: [], conflicts: [], conflictPips: [], cardInstances: [], moves: [], goals: [], sceneGoals: [], assets: [], sceneAssets: [], subplots: [], subplotsProgress: [], hostActions: [], selectedGameIdx: 0
            };
            function parseTables(text) {
                const lines = text.split(/\r?\n/);
                let currentTable = null;
                let columns = [];
                let tables = {};
                for (let line of lines) {
                    line = line.trim();
                    if (!line || line.startsWith('//')) { currentTable = null; continue; }
                    if (line.startsWith('tbl') && line.includes(':')) {
                        const [tableName, colStr] = line.split(':');
                        columns = colStr.split('|').map(s => s.trim());
                        currentTable = tableName.trim();
                        tables[currentTable] = tables[currentTable] || [];
                        continue;
                    }
                    if (currentTable) {
                        const values = line.split('|').map(s => s.trim());
                        let row = {};
                        columns.forEach((col, i) => row[col] = values[i] !== undefined ? values[i] : null);
                        tables[currentTable].push(row);
                    }
                }
                return tables;
            }
            function buildDataModelFromTables(tables) {
                function int(v) { return v === undefined || v === null ? null : parseInt(v, 10); }
                state.games = (tables.tblGames||[]).map(r => ({ id: int(r.id), name: r.name, desc: r.desc }));
                state.players = (tables.tblPlayers||[]).map(r => ({ id: int(r.id), name: r.name }));
                state.gameSettings = (tables.tblGameSettings||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), key: r.setting_key, value: r.setting_value }));
                state.characters = (tables.tblCharacters||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), name: r.name, status: r.status, is_pc: r.is_pc === '1' }));
                state.playersCharacters = (tables.tblPlayersCharacters||[]).map(r => ({ id: int(r.id), player_id: int(r.player_id), character_id: int(r.character_id), is_primary: r.is_primary === '1' }));
                state.cardTypes = (tables.tblCardTypes||[]).map(r => ({ id: int(r.id), name: r.name, category: r.category, is_wild: r.is_wild === '1' }));
                state.cards = (tables.tblCards||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), name: r.name, desc: r.desc, card_type_id: int(r.card_type_id) }));
                state.charactersCards = (tables.tblCharactersCards||[]).map(r => ({ id: int(r.id), character_id: int(r.character_id), card_id: int(r.card_id), count: int(r.count) }));
                state.scenes = (tables.tblScenes||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), name: r.name, desc: r.desc, place_card_id: int(r.place_card_id), status: r.status, intro_narration: r.intro_narration }));
                state.sceneCharacters = (tables.tblSceneCharacters||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), character_id: int(r.character_id), is_npc: r.is_npc === '1' }));
                state.conflicts = (tables.tblConflicts||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), card_id: int(r.card_id), type: r.type, name: r.name, desc: r.desc, max_pips: int(r.max_pips), status: r.status }));
                state.conflictPips = (tables.tblConflictPips||[]).map(r => ({ id: int(r.id), conflict_id: int(r.conflict_id), pip_number: int(r.pip_number), assigned_character_id: int(r.assigned_character_id), assigned_card_instance_id: int(r.assigned_card_instance_id), outcome: r.outcome, narrative: r.narrative }));
                state.cardInstances = (tables.tblCardInstances||[]).map(r => ({ id: int(r.id), card_id: int(r.card_id), owner_character_id: int(r.owner_character_id), scene_id: int(r.scene_id), custom_name: r.custom_name, custom_desc: r.custom_desc, timestamp: r.timestamp, spent: r.spent === '1' }));
                state.moves = (tables.tblMoves||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), conflict_id: int(r.conflict_id), card_instance_id: int(r.card_instance_id), player_id: int(r.player_id), text: r.text, timestamp: r.timestamp }));
                state.goals = (tables.tblGoals||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), name: r.name, desc: r.desc }));
                state.sceneGoals = (tables.tblSceneGoals||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), goal_id: int(r.goal_id), assigned_character_id: int(r.assigned_character_id), status: r.status }));
                state.assets = (tables.tblAssets||[]).map(r => ({ id: int(r.id), game_id: int(r.game_id), name: r.name, desc: r.desc }));
                state.sceneAssets = (tables.tblSceneAssets||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), asset_id: int(r.asset_id), assigned_character_id: int(r.assigned_character_id), status: r.status }));
                state.subplots = (tables.tblSubplots||[]).map(r => ({ id: int(r.id), card_id: int(r.card_id), name: r.name, desc: r.desc }));
                state.subplotsProgress = (tables.tblSubplotsProgress||[]).map(r => ({ id: int(r.id), character_id: int(r.character_id), subplot_id: int(r.subplot_id), scene_id: int(r.scene_id), progress_note: r.progress_note, timestamp: r.timestamp }));
                state.hostActions = (tables.tblHostActions||[]).map(r => ({ id: int(r.id), scene_id: int(r.scene_id), action_type: r.action_type, details: r.details, timestamp: r.timestamp }));
            }
            // CRUD and accessors
            function getGames() { return state.games; }
            function getSelectedGameIdx() { return state.selectedGameIdx; }
            function setSelectedGameIdx(idx) { state.selectedGameIdx = idx; }
            function getPlayers() { return state.players; }
            function getGameSettings() { return state.gameSettings; }
            function getCharacters() { return state.characters; }
            function getScenes() { return state.scenes; }
            function createGame(name) {
                const newGame = { id: state.games.length ? Math.max(...state.games.map(g=>g.id||0))+1 : 1, name, desc: '', scenes: [] };
                state.games.push(newGame);
                state.selectedGameIdx = state.games.length - 1;
                return newGame;
            }
            function removeGame(idx) {
                if (state.games.length === 0) return;
                state.games.splice(idx, 1);
                state.selectedGameIdx = Math.max(0, state.selectedGameIdx - 1);
            }
            function updateGame(idx, name) {
                if (state.games.length === 0) return;
                state.games[idx].name = name;
            }
            function updateGameDesc(idx, desc) {
                if (state.games.length === 0) return;
                state.games[idx].desc = desc;
            }
            return {
                parseTables, buildDataModelFromTables, getGames, getSelectedGameIdx, setSelectedGameIdx, getPlayers, getGameSettings, getCharacters, getScenes, createGame, removeGame, updateGame, updateGameDesc,
                _state: state // for debugging
            };
        })();

        // --- StoriumUIX: UI IIFE ---
        window.StoriumUIX = (function() {
            // All UI rendering and event logic
            function renderGamesDropdown(games, selectedIdx) {
                const dd = document.getElementById('gamesDropdown');
                dd.innerHTML = '';
                games.forEach((g, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = g.name;
                    dd.appendChild(opt);
                });
                dd.selectedIndex = selectedIdx;
            }
            function renderTreeView(game, allData) {
                loadCssManagement(function() {
                    const DOMHandler = window.CssManagement.DOMHandler;
                    const container = document.getElementById('treeView');
                    container.innerHTML = '';
                    if (!game) return;

                    // Game Desc & Settings
                    const gameDesc = DOMHandler.createElement('div', { class: 'tree-item' });
                    DOMHandler.appendChild(gameDesc, DOMHandler.createElement('span', { class: 'tree-label', textContent: 'Desc:' }));
                    DOMHandler.appendChild(gameDesc, DOMHandler.createElement('span', { textContent: game.desc || '(none)' }));
                    DOMHandler.appendChild(gameDesc, DOMHandler.createElement('button', { class: 'crud-btn', title: 'Edit Desc', 'data-action': 'editGameDesc', textContent: 'âœŽ' }));
                    DOMHandler.appendChild(container, gameDesc);

                    // Game Settings
                    const settings = allData.gameSettings.filter(s => s.game_id === game.id);
                    if (settings.length) {
                        const settingsDiv = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(settingsDiv, DOMHandler.createElement('b', { textContent: 'Settings' }));
                        const ul = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        settings.forEach(s => {
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: s.key + ':' }));
                            DOMHandler.appendChild(li, document.createTextNode(' ' + s.value));
                            DOMHandler.appendChild(ul, li);
                        });
                        DOMHandler.appendChild(settingsDiv, ul);
                        DOMHandler.appendChild(container, settingsDiv);
                    }

                    // Players
                    const players = allData.players;
                    if (players.length) {
                        const playersDiv = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(playersDiv, DOMHandler.createElement('b', { textContent: 'Players' }));
                        const ul = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        players.forEach(p => {
                            const li = DOMHandler.createElement('li', { textContent: p.name });
                            DOMHandler.appendChild(ul, li);
                        });
                        DOMHandler.appendChild(playersDiv, ul);
                        DOMHandler.appendChild(container, playersDiv);
                    }

                    // Scenes group
                    const scenes = allData.scenes.filter(s => s.game_id === game.id);
                    const sceneCharacters = allData.sceneCharacters;
                    const characters = allData.characters.filter(c => c.game_id === game.id);
                    const cardTypes = allData.cardTypes;
                    const cards = allData.cards.filter(c => c.game_id === game.id);
                    const conflicts = allData.conflicts;
                    const conflictPips = allData.conflictPips;
                    const cardInstances = allData.cardInstances;
                    const moves = allData.moves;
                    const goals = allData.goals.filter(g => g.game_id === game.id);
                    const sceneGoals = allData.sceneGoals;
                    const assets = allData.assets.filter(a => a.game_id === game.id);
                    const sceneAssets = allData.sceneAssets;

                    const scenesGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                    DOMHandler.appendChild(scenesGroup, DOMHandler.createElement('b', { textContent: 'Scenes' }));
                    DOMHandler.appendChild(scenesGroup, DOMHandler.createElement('button', { class: 'crud-btn', title: 'Add Scene', 'data-action': 'addScene', textContent: 'ï¼‹' }));
                    scenes.forEach((scene, si) => {
                        const sceneDiv = DOMHandler.createElement('div', { class: 'scene tree-group' });
                        // Scene header
                        const sceneHeader = DOMHandler.createElement('div', { class: 'tree-item' });
                        DOMHandler.appendChild(sceneHeader, DOMHandler.createElement('span', { class: 'tree-label', textContent: scene.name }));
                        DOMHandler.appendChild(sceneHeader, DOMHandler.createElement('span', { style: 'font-size:0.9em;color:#888;', textContent: '[' + scene.status + ']' }));
                        DOMHandler.appendChild(sceneHeader, DOMHandler.createElement('button', { class: 'crud-btn', title: 'Edit Scene', 'data-action': 'editScene', 'data-si': si, textContent: 'âœŽ' }));
                        DOMHandler.appendChild(sceneHeader, DOMHandler.createElement('button', { class: 'crud-btn', title: 'Remove Scene', 'data-action': 'removeScene', 'data-si': si, textContent: 'ðŸ—‘' }));
                        DOMHandler.appendChild(sceneDiv, sceneHeader);
                        // Scene desc
                        const sceneDesc = DOMHandler.createElement('div', { class: 'desc tree-item' });
                        DOMHandler.appendChild(sceneDesc, DOMHandler.createElement('span', { class: 'tree-label', textContent: 'Desc:' }));
                        DOMHandler.appendChild(sceneDesc, DOMHandler.createElement('span', { textContent: scene.desc || '(none)' }));
                        DOMHandler.appendChild(sceneDesc, DOMHandler.createElement('button', { class: 'crud-btn', title: 'Edit Desc', 'data-action': 'editSceneDesc', 'data-si': si, textContent: 'âœŽ' }));
                        DOMHandler.appendChild(sceneDiv, sceneDesc);
                        // Pips
                        const pipsDiv = DOMHandler.createElement('div', { class: 'tree-item' });
                        DOMHandler.appendChild(pipsDiv, DOMHandler.createElement('span', { class: 'tree-label', textContent: 'Pips:' }));
                        DOMHandler.appendChild(pipsDiv, document.createTextNode((conflicts.filter(c=>c.scene_id===scene.id).reduce((acc,c)=>acc+(c.max_pips||0),0)).toString()));
                        DOMHandler.appendChild(sceneDiv, pipsDiv);

                        // Obstacles
                        const obsGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(obsGroup, DOMHandler.createElement('b', { textContent: 'Obstacles' }));
                        const obsUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        conflicts.filter(c=>c.scene_id===scene.id && c.type==='obstacle').forEach(ob => {
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: ob.name }));
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { style: 'color:#888;', textContent: `[${ob.status}${ob.outcome ? ', ' + ob.outcome : ''}]` }));
                            DOMHandler.appendChild(obsUl, li);
                        });
                        DOMHandler.appendChild(obsGroup, obsUl);
                        DOMHandler.appendChild(sceneDiv, obsGroup);

                        // Character Conflicts
                        const charConfGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(charConfGroup, DOMHandler.createElement('b', { textContent: 'Character Conflicts' }));
                        const charConfUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        conflicts.filter(c=>c.scene_id===scene.id && c.type==='character').forEach(ob => {
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: ob.name }));
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { style: 'color:#888;', textContent: `[${ob.status}${ob.outcome ? ', ' + ob.outcome : ''}]` }));
                            DOMHandler.appendChild(charConfUl, li);
                        });
                        DOMHandler.appendChild(charConfGroup, charConfUl);
                        DOMHandler.appendChild(sceneDiv, charConfGroup);

                        // Scene Characters
                        const scGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(scGroup, DOMHandler.createElement('b', { textContent: 'Scene Characters' }));
                        const scUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        sceneCharacters.filter(sc=>sc.scene_id===scene.id).forEach(sc => {
                            const char = characters.find(c=>c.id===sc.character_id);
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: char ? char.name : '' }));
                            DOMHandler.appendChild(scUl, li);
                        });
                        DOMHandler.appendChild(scGroup, scUl);
                        DOMHandler.appendChild(sceneDiv, scGroup);

                        // Goals
                        const goalsGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(goalsGroup, DOMHandler.createElement('b', { textContent: 'Goals' }));
                        const goalsUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        sceneGoals.filter(g=>g.scene_id===scene.id).forEach(goal => {
                            const g = goals.find(x=>x.id===goal.goal_id);
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: g ? g.name : '' }));
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { style: 'color:#888;', textContent: `[${goal.status}]` }));
                            DOMHandler.appendChild(goalsUl, li);
                        });
                        DOMHandler.appendChild(goalsGroup, goalsUl);
                        DOMHandler.appendChild(sceneDiv, goalsGroup);

                        // Assets
                        const assetsGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(assetsGroup, DOMHandler.createElement('b', { textContent: 'Assets' }));
                        const assetsUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        sceneAssets.filter(a=>a.scene_id===scene.id).forEach(asset => {
                            const a = assets.find(x=>x.id===asset.asset_id);
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: a ? a.name : '' }));
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { style: 'color:#888;', textContent: `[${asset.status}]` }));
                            DOMHandler.appendChild(assetsUl, li);
                        });
                        DOMHandler.appendChild(assetsGroup, assetsUl);
                        DOMHandler.appendChild(sceneDiv, assetsGroup);

                        // Moves
                        const movesGroup = DOMHandler.createElement('div', { class: 'tree-group' });
                        DOMHandler.appendChild(movesGroup, DOMHandler.createElement('b', { textContent: 'Moves' }));
                        const movesUl = DOMHandler.createElement('ul', { style: 'margin:0 0 0 16px;' });
                        moves.filter(m=>m.scene_id===scene.id).forEach(move => {
                            const char = characters.find(c=>c.id===cardInstances.find(ci=>ci.id===move.card_instance_id)?.owner_character_id);
                            const li = DOMHandler.createElement('li');
                            DOMHandler.appendChild(li, DOMHandler.createElement('span', { class: 'tree-label', textContent: char ? char.name : '' }));
                            DOMHandler.appendChild(li, document.createTextNode(': ' + move.text));
                            DOMHandler.appendChild(movesUl, li);
                        });
                        DOMHandler.appendChild(movesGroup, movesUl);
                        DOMHandler.appendChild(sceneDiv, movesGroup);

                        DOMHandler.appendChild(scenesGroup, sceneDiv);
                    });
                    DOMHandler.appendChild(container, scenesGroup);
                });
            }
            return {
                renderGamesDropdown,
                renderTreeView
            };
        })();

        // --- StoriumService: Service/Traffic IIFE ---
        window.StoriumService = (function() {
            const Data = window.StoriumData;
            const UIX = window.StoriumUIX;
            // Example: wire up dropdown
            function updateGamesDropdown() {
                UIX.renderGamesDropdown(Data.getGames(), Data.getSelectedGameIdx());
            }
            function updateTreeView() {
                const games = Data.getGames();
                const idx = Data.getSelectedGameIdx();
                UIX.renderTreeView(games[idx], {
                    players: Data.getPlayers(),
                    gameSettings: Data.getGameSettings(),
                    characters: Data.getCharacters(),
                    scenes: Data.getScenes(),
                    cardTypes: Data._state.cardTypes,
                    cards: Data._state.cards,
                    conflicts: Data._state.conflicts,
                    conflictPips: Data._state.conflictPips,
                    cardInstances: Data._state.cardInstances,
                    moves: Data._state.moves,
                    goals: Data._state.goals,
                    sceneGoals: Data._state.sceneGoals,
                    assets: Data._state.assets,
                    sceneAssets: Data._state.sceneAssets,
                    subplots: Data._state.subplots,
                    subplotsProgress: Data._state.subplotsProgress,
                    hostActions: Data._state.hostActions,
                });
            }
            // Example: create game
            function createGame() {
                const name = prompt("Game name?");
                if (!name) return;
                Data.createGame(name);
                updateGamesDropdown();
                updateTreeView();
            }
            // ...other service/traffic logic...
            return {
                updateGamesDropdown,
                updateTreeView,
                createGame
            };
        })();

        // --- Wire up UI and events using the new modular IIFEs ---
        function showTab(idx) {
            document.querySelectorAll('.tab').forEach((t, i) => t.classList.toggle('active', i === idx));
            document.querySelectorAll('.tab-content').forEach((c, i) => c.classList.toggle('active', i === idx));
            if (idx === 0) window.StoriumService.updateTreeView();
        }

        window.addEventListener('DOMContentLoaded', function() {
            // Tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const idx = parseInt(tab.getAttribute('data-tab'), 10);
                    showTab(idx);
                });
            });
            // Games dropdown
            document.getElementById('gamesDropdown').onchange = function() {
                window.StoriumData.setSelectedGameIdx(this.selectedIndex);
                window.StoriumService.updateTreeView();
            };
            // CRUD buttons
            document.querySelector('button[title="Create Game"]').onclick = window.StoriumService.createGame;
            // (Remove and update game can be added to service as needed)
            // Table Builder
            document.querySelector('button.icon-btn[onclick*="buildTables"]').onclick = function() {
                const text = document.getElementById('tableTextArea').value;
                const tables = window.StoriumData.parseTables(text);
                window.StoriumData.buildDataModelFromTables(tables);
                if (window.StoriumData.getGames().length > 0) window.StoriumData.setSelectedGameIdx(0);
                window.StoriumService.updateGamesDropdown();
                window.StoriumService.updateTreeView();
            };
            document.querySelector('button.icon-btn[onclick*="loadFromTree"]').onclick = function() {
                // Placeholder: implement as needed
                alert('Load from Tree (not implemented)');
            };
            // Initial render
            window.StoriumService.updateGamesDropdown();
            window.StoriumService.updateTreeView();
        });
